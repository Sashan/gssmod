dnl This program is free software; you can redistribute it and/or modify
dnl it under the terms of the GNU General Public License as published by
dnl the Free Software Foundation; either version 2 of the License, or
dnl (at your option) any later version.
dnl
dnl This program is distributed in the hope that it will be useful,
dnl but WITHOUT ANY WARRANTY; without even the implied warranty of
dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
dnl GNU General Public License for more details.
dnl
dnl You should have received a copy of the GNU General Public License
dnl along with this program; if not, write to the Free Software
dnl Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
dnl
dnl Process this file with autoconf to produce a configure script.

AC_INIT([mod_gss],[1.3.0],[markus_moeller@compuserve.com])

enable_arg="no"

dnl Define MIT libraries
AC_ARG_ENABLE(mit,
  [  --enable-mit		  enable use of MIT package (default=yes) ],
  [
    if test "$enableeval" != "no" ; then
       AC_DEFINE(HAVE_INIT_CREDS_PASSWORD,1,[Define krb5_get_init_creds_password])
       ac_gss_libs="-lgssapi_krb5 -ldes425 -lkrb5 -lk5crypto -lcom_err"
       enable_arg="mit"
    fi ])

dnl Define Heimdal libraries
AC_ARG_ENABLE(heimdal,
  [  --enable-heimdal	  enable use of Heimdal package (default=no) ],
  [
    if test "$enableeval" != "no" ; then
       AC_DEFINE(HAVE_HEIMDAL_KERBEROS,1,[Define Heimdal Kerberos])
       AC_DEFINE(HAVE_INIT_CREDS_PASSWORD,1,[Define krb5_get_init_creds_password])
       ac_gss_libs="-lgssapi -lkrb5 -lcom_err -lasn1 -lroken";
       enable_arg="heimdal"
    fi ])

dnl Define SEAM libraries
AC_ARG_ENABLE(seam,
  [  --enable-seam		  enable use of SEAM(Solaris) package (default=no) ],
  [
    if test "$enableeval" != "no" ; then
       AC_DEFINE(HAVE_SEAM_KERBEROS,1,[Define SEAM Kerberos])
       CPPFLAGS_sav=$CPPFLAGS;
       CPPFLAGS="-I/usr/src/uts/common/gssapi/mechs/krb5/include"; 
       AC_CHECK_HEADERS(krb5.h)
       CPPFLAGS=$CPPFLAGS_sav;
       AC_CHECK_HEADERS(security/pkcs11t.h)
       AC_TRY_COMPILE([#include <gssapi/gssapi.h>],
       [gss_int32 gint;],
       AC_DEFINE(HAVE_GSS_INT32,1,[Define gss_int32]),)
       if test -e /usr/lib/gss/do/mech_krb5.so ; then
          ac_gss_libs="-lgss -R\/usr\/lib\/gss\/do \/usr\/lib\/gss\/do\/mech_krb5.so";
          ln -s /usr/lib/gss/do/mech_krb5.so /tmp/libmech_krb5.so;
          LDFLAGS_sav=$LDFLAGS;
          LDFLAGS="-L/tmp"; 
          AC_CHECK_LIB(mech_krb5,krb5_get_init_creds_password,AC_DEFINE(HAVE_INIT_CREDS_PASSWORD,1,[Define krb5_get_init_creds_password]),AC_DEFINE(HAVE_INIT_CREDS_PASSWORD,0,[UnDefine krb5_get_init_creds_password]))
          LDFLAGS=$LDFLAGS_sav
          rm /tmp/libmech_krb5.so
       elif test -e /usr/lib/gss/gl/mech_krb5.so ; then
          ac_gss_libs="-lgss -R\/usr\/lib\/gss\/gl \/usr\/lib\/gss\/gl\/mech_krb5.so";
          ln -s /usr/lib/gss/gl/mech_krb5.so /tmp/libmech_krb5.so;
          LDFLAGS_sav=$LDFLAGS;
          LDFLAGS="-L/tmp"; 
          AC_CHECK_LIB(mech_krb5,krb5_get_init_creds_password,AC_DEFINE(HAVE_INIT_CREDS_PASSWORD,1,[Define krb5_get_init_creds_password]),AC_DEFINE(HAVE_INIT_CREDS_PASSWORD,0,[UnDefine krb5_get_init_creds_password]))
          LDFLAGS=$LDFLAGS_sav
          rm /tmp/libmech_krb5.so
       else
          ac_gss_libs="-lgss -R\/usr\/lib\/gss \/usr\/lib\/gss\/mech_krb5.so";
          ln -s /usr/lib/gss/mech_krb5.so /tmp/libmech_krb5.so;
          LDFLAGS_sav=$LDFLAGS;
          LDFLAGS="-L/tmp"; 
          AC_CHECK_LIB(mech_krb5,krb5_get_init_creds_password,AC_DEFINE(HAVE_INIT_CREDS_PASSWORD,1,[Define krb5_get_init_creds_password]),AC_DEFINE(HAVE_INIT_CREDS_PASSWORD,0,[UnDefine krb5_get_init_creds_password]))
          LDFLAGS=$LDFLAGS_sav
          rm /tmp/libmech_krb5.so
       fi
       enable_arg="seam"
    fi ])

dnl Define NAS libraries
AC_ARG_ENABLE(nas,
  [  --enable-nas 		  enable use of NAS(AIX) package (default=no) ],
  [
    if test "$enableeval" != "no" ; then
       AC_DEFINE(HAVE_NAS_KERBEROS,1,[Define NAS Kerberos])
       AC_DEFINE(HAVE_INIT_CREDS_PASSWORD,1,[Define krb5_get_init_creds_password])
       ac_gss_libs="-L\/usr\/lib -lksvc -lgssapi_krb5 -lkrb5";
       enable_arg="nas"
    fi ])

dnl Define MIT as default 
if test "$enable_arg" = "no"; then
   AC_DEFINE(HAVE_INIT_CREDS_PASSWORD,1,[Define krb5_get_init_creds_password])
   ac_gss_libs="-lgssapi_krb5 -ldes425 -lkrb5 -lk5crypto -lcom_err"
fi

AC_CHECK_FUNCS(unsetenv)
AC_CONFIG_HEADER(mod_gss.h)
AH_TOP([/*
 * mod_gss - an RFC2228 GSSAPI module for ProFTPD
 *
 * Copyright (c) 2002-2005 M Moeller <|MAIL|>
 * All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
 *
 * As a special exemption, M Moeller gives permission to link this program
 * with MIT, Heimdal or other GSS/Kerberos libraries, and distribute
 * the resulting executable, without including the source code for
 * the Libraries in the source distribution.
 *
 */
])
AH_BOTTOM([#include "conf.h"
#include "privs.h"

/* Make sure the version of proftpd is as necessary. */
#if PROFTPD_VERSION_NUMBER < 0x0001030001
# error "ProFTPD 1.3.0rc1 or later required"
#endif

#ifdef HAVE_HEIMDAL_KERBEROS
#include <gssapi.h>
#include <krb5.h>
#define error_message(code) krb5_get_err_text(NULL,code)
#define gss_nt_service_name GSS_C_NT_HOSTBASED_SERVICE
#define gss_int32 int32_t
#else
#ifdef HAVE_SEAM_KERBEROS
#include <gssapi/gssapi.h>
#include <gssapi/gssapi_ext.h>
#define gss_nt_service_name GSS_C_NT_HOSTBASED_SERVICE
#ifndef HAVE_GSS_INT32
#define gss_int32 int32_t
#endif

#ifdef HAVE_KRB5_H
/* still testing this for OpenSolaris
#include "/usr/src/uts/common/gssapi/mechs/krb5/include/krb5.h"
*/
#else
/* Seam doesn't have krb5.h so define all here. Assume SEAM is based on MIT sources */
#define KRB5KDC_ERR_CLIENT_REVOKED               (-1765328366L)
#define KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN          (-1765328378L)
#define KRB5KDC_ERR_PREAUTH_FAILED               (-1765328360L)

#if (SIZEOF_INT == 4)
typedef int             krb5_int32;
typedef unsigned int    krb5_ui_4;
#define VALID_INT_BITS    0x7fffffff
#define VALID_UINT_BITS   0xffffffff
#elif (SIZEOF_LONG == 4)
typedef long    krb5_int32;
typedef unsigned long   krb5_ui_4;
#elif (SIZEOF_SHORT == 4)
typedef short   krb5_int32;
typedef unsigned short  krb5_ui_4;
#else
 ?== error: undefined 32 bit type
#endif

typedef unsigned char   krb5_octet;
typedef unsigned int    krb5_boolean;

typedef krb5_int32      krb5_addrtype;
typedef krb5_int32      krb5_enctype;
typedef krb5_int32      krb5_authdatatype;
typedef krb5_int32      krb5_keyusage;
typedef krb5_int32      krb5_preauthtype;
typedef krb5_int32      krb5_flags;
typedef krb5_int32      krb5_timestamp;
typedef krb5_int32      krb5_error_code;
typedef krb5_int32      krb5_deltat;

typedef krb5_error_code krb5_magic;

struct  _krb5_context;
typedef struct _krb5_context *krb5_context;

typedef struct _krb5_data {
        krb5_magic magic;
        unsigned int length;
        char *data;
} krb5_data;

typedef struct krb5_principal_data {
    krb5_magic magic;
    krb5_data realm;
    krb5_data *data;            /* An array of strings */
    krb5_int32 length;
    krb5_int32 type;
} krb5_principal_data;

typedef krb5_principal_data *krb5_principal;

#ifdef HAVE_SECURITY_PKCS11T_H
struct _krb5_keyblock;

/*
 * keyblocks will contain a list of derived keys,
 * this  structure will contain the derived key data.
 */
typedef struct _dk_node {
    krb5_keyusage   usage;
    struct _krb5_keyblock   *derived_key;
    uchar_t         dkid; /* derived key identifier byte */
    struct _dk_node *next;
} krb5_dk_node;

/* an unsigned value, at least 32 bits long */
typedef unsigned long int CK_ULONG;
typedef CK_ULONG          CK_OBJECT_HANDLE;
#endif

typedef struct _krb5_keyblock {
    krb5_magic magic;
    krb5_enctype enctype;
    unsigned int length;
    krb5_octet *contents;
#ifdef HAVE_SECURITY_PKCS11T_H
    krb5_dk_node   *dk_list; /* list of keys derived from this key */
#ifdef _KERNEL
    crypto_mech_type_t     kef_mt;
    crypto_key_t           kef_key;
    crypto_ctx_template_t  key_tmpl;
#else
    CK_OBJECT_HANDLE       hKey; /* PKCS#11 key object handle */
    pid_t       pid; /* fork safety */
#endif /* _KERNEL */
#endif
} krb5_keyblock;

typedef struct _krb5_ticket_times {
    krb5_timestamp authtime;
    krb5_timestamp starttime;
    krb5_timestamp endtime;
    krb5_timestamp renew_till;
} krb5_ticket_times;

typedef struct _krb5_address {
    krb5_magic magic;
    krb5_addrtype addrtype;
    unsigned int length;
    krb5_octet *contents;
} krb5_address;

typedef struct _krb5_authdata {
    krb5_magic magic;
    krb5_authdatatype ad_type;
    unsigned int length;
    krb5_octet *contents;
} krb5_authdata;

typedef struct _krb5_creds {
    krb5_magic magic;
    krb5_principal client;
    krb5_principal server;
    krb5_keyblock keyblock;
    krb5_ticket_times times;
    krb5_boolean is_skey;
    krb5_flags ticket_flags;
    krb5_address **addresses;
    krb5_data ticket;
    krb5_data second_ticket;
    krb5_authdata **authdata;
} krb5_creds;

typedef struct _krb5_get_init_creds_opt {
    krb5_flags flags;
    krb5_deltat tkt_life;
    krb5_deltat renew_life;
    int forwardable;
    int proxiable;
    krb5_enctype *etype_list;
    int etype_list_length;
    krb5_address **address_list;
    krb5_preauthtype *preauth_list;
    int preauth_list_length;
    krb5_data *salt;
} krb5_get_init_creds_opt;

typedef struct _krb5_prompt {
    char *prompt;
    int hidden;
    krb5_data *reply;
} krb5_prompt;

#ifndef KRB5_CONFIG__
#ifndef KRB5_CALLCONV
#define KRB5_CALLCONV
#define KRB5_CALLCONV_C
#endif /* !KRB5_CALLCONV */
#endif /* !KRB5_CONFIG__ */

typedef krb5_error_code (KRB5_CALLCONV *krb5_prompter_fct)(krb5_context context,
                                             void *data,
                                             const char *name,
                                             const char *banner,
                                             int num_prompts,
                                             krb5_prompt prompts[]);

char *error_message(long code);

#if defined(KRB5_NO_CONST) || (defined(__ultrix) && !defined(__GNUC__))
#define krb5_const
#else
#define krb5_const const
#endif

#if (defined(__STDC__) || defined(__cplusplus) || defined(_MSDOS) || defined(_WIN32) || defined(KRB5_PROVIDE_PROTOTYPES)) && !defined(KRB5_NO_PROTOTYPES)
#define KRB5_PROTOTYPE(x) x
#if defined(__STDC__) || defined(__cplusplus) || defined(HAVE_STDARG_H) || defined(_MSDOS) || defined(_WIN32)
#define KRB5_STDARG_P(x) x
#else
#define KRB5_STDARG_P(x) ()
#endif /* defined(__STDC__) || defined(__cplusplus) || defined(HAVE_STDARG_H) */
#else
#define KRB5_PROTOTYPE(x) ()
#define KRB5_STDARG_P(x) ()
#endif /* STDC or PROTOTYPES */

void KRB5_CALLCONV krb5_free_context 
        KRB5_PROTOTYPE((krb5_context));
void KRB5_CALLCONV krb5_free_principal
        KRB5_PROTOTYPE((krb5_context, krb5_principal ));

krb5_boolean KRB5_CALLCONV krb5_kuserok
        KRB5_PROTOTYPE((krb5_context,
                krb5_principal, const char *));

krb5_error_code KRB5_CALLCONV krb5_init_context
        KRB5_PROTOTYPE((krb5_context *));
krb5_error_code KRB5_CALLCONV krb5_timeofday
        KRB5_PROTOTYPE((krb5_context,
                   krb5_int32 * ));
krb5_error_code KRB5_CALLCONV krb5_parse_name
        KRB5_PROTOTYPE((krb5_context,
                   krb5_const char *,
                   krb5_principal * ));

#ifdef HAVE_INIT_CREDS_PASSWORD
krb5_error_code KRB5_CALLCONV
krb5_get_init_creds_password
KRB5_PROTOTYPE((krb5_context context,
                krb5_creds *creds,
                krb5_principal client,
                char *password,
                krb5_prompter_fct prompter,
                void *data,
                krb5_deltat start_time,
                char *in_tkt_service,
                krb5_get_init_creds_opt *options));
#endif
#endif /*HAVE_KRB5_H */
#else /*MIT*/
#include <gssapi/gssapi.h>
#include <gssapi/gssapi_generic.h>
#include <gssapi/gssapi_krb5.h>
#ifdef HAVE_NAS_KERBEROS
#include <ibm_svc/krb5_svc.h>
const char *KRB5_CALLCONV error_message(long code) {
 char *msg=NULL;
 krb5_svc_get_msg(code,&msg);
 return msg;
}
#endif
#endif
#endif

#ifndef GSS_C_AF_INET6
#define GSS_C_AF_INET6 24
#endif

#define MOD_GSS_VERSION         PACKAGE_NAME"/"PACKAGE_VERSION
#define C_FWCCC   "FWCCC"       /* FW support PORT/EPORT/PASV/EPASV in clear */

extern session_t session;
extern xaset_t *server_list;

#ifndef HAVE_UNSETENV
void unsetenv(char *env_name) {
  extern char **environ;
  char **cc;
  int l;
  l=strlen(env_name);
  for (cc=environ;*cc!=NULL;cc++) {
    if (strncmp(env_name,*cc,l)==0 && ((*cc)[l]=='='||(*cc)[l]=='\0')) break;
  } for (; *cc != NULL; cc++) *cc=cc[1];
}
#endif

])
AC_OUTPUT()

echo "configure: updating mod_gss.h"
sed -e "s/|MAIL|/"$PACKAGE_BUGREPORT"/" mod_gss.h > .mod_gss.h.tmp
mv .mod_gss.h.tmp mod_gss.h

echo "configure: updating \$Libraries in mod_gss.c"
if test -e mod_gss.c ; then
  sed -e "s/\$Libraries:.*/\$Libraries: |GSS_LIBS|\$/" mod_gss.c > mod_gss.c.in
  rm mod_gss.c
fi 
sed -e "s/|GSS_LIBS|/$ac_gss_libs/" mod_gss.c.in > .mod_gss.c.tmp
mv .mod_gss.c.tmp mod_gss.c

